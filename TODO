===============================================================================
= current
===============================================================================
cursors:
  additional operator for multiple transformations in sequence
    more concise and more efficient
  default void constructor for :=% and friends
    won't be able to support varargs versions, but this is fine
  support non-list pairs

consolidate ui.rkt
  a lot of this is unnecessary

markout:
  design is sucking due to too many special cases; can it be fixed?
  seem to need height management, not just width
    draw tables twice, measuring the first time to provide measurement the second time?
      simplest quick fix; not a long term solution

repr:
  procedure reprs
  any<, any<=, and type-specific comparison operators
    approximate for structs using object-name?

kanren:
  and/or/not?
  redefine =/= in terms of 'or'
    will eliminate more redundancies
  redefine < in terms of compare
  remove deps upon use
  convenient admission of function interpretations
  reification
    deterministic sub-func ordering
    ignore irrelevant sub-funcs
    prettier function-based constraints
      also prune more redundancies
  support alternative search strategies
  constraints
    optional occurs-check?
    https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/impl/occur.html
      interesting sub-thread between torkel and pereira
  fix hash unification
  extended aggregate unification?
    sets and hashes with variable keys may have multiple component orderings
      unification could produce multiple possible subs

===============================================================================
= future
===============================================================================
logic/relational programming
  oleg's lambda term generation: http://okmij.org/ftp/Haskell/AlgorithmsH1.html#random-term

simple proof checker
