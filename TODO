===============================================================================
= current
===============================================================================
cursors:
  additional operator for multiple transformations in sequence
    more concise and more efficient
  default void constructor for :=% and friends
    won't be able to support varargs versions, but this is fine
  support non-list pairs

consolidate ui.rkt
  a lot of this is unnecessary

markout:
  design is sucking due to too many special cases; can it be fixed?
  seem to need height management, not just width
    draw tables twice, measuring the first time to provide measurement the second time?
      simplest quick fix; not a long term solution
  http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf

kanren:
  measure substitution size growth
  compare efficiency of idempotent substitutions
  run: optionally take a single query-var rather than a list
    requires a change (simplification) to reify
  clean up reify
  constraints
    CHR
      https://en.wikipedia.org/wiki/Constraint_Handling_Rules
      http://www.informatik.uni-ulm.de/pm/fileadmin/pm/home/fruehwirth/constraint-handling-rules-book.html
      http://chr.informatik.uni-ulm.de/~webchr/
      http://www.csse.monash.edu.au/~mbanda/papers/refined.pdf
    optional occurs-check?
    https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/impl/occur.html
      interesting sub-thread between torkel and pereira
  minicurry
    match scheme syntax more closely to simplify porting
      some form of macros
      let[*]: wrap args, allow body to be conjunction, optional let-naming for looping
      letr: wrap args, allow body to be conjunction
        *maybe* generalize to take arbitrary arg values, not just lambdas
    metacircular interpreter
      may need to wait for additional constraints
      experiment with separating syntactic analysis from evaluation
      quines?
    experiment with small-step operational semantics
    benchmarks?
      particularly related to substitution size once this is measurable
    maybe try extending microkanren with by-need suspended computations, triggered by pause
      appropriate suspension to be unfrozen is identified by a key provided by pause
  encodings (such as full-repr) instead of additional constraint system layers
    example: unification of type-encoded values eliminates the need for type constraints
      (symbolo x) ===> (exist (val) (== x (('symbol ()) val)))
      or
      (naturalo x) ===> (exist (val) (== x (('(number real exact integer natural) ()) val)))
      where x is a val that has been lifted by full-repr
    not even 1st class =/= is necessary with the right encoding
      but =/= being 1st class may be much more efficient for many structures
    alternative to functions: implicit encodings that take effect on all unified values
      reification can then perform decoding
  implicit views
    view, unview
    tagging
    =/=
    constraint-like reification
  remove function terms
  improve performance
  extended aggregate unification?
    sets and hashes with variable keys may have multiple component orderings
      unification could produce multiple possible subs

===============================================================================
= future
===============================================================================
logic/relational programming
  oleg's lambda term generation: http://okmij.org/ftp/Haskell/AlgorithmsH1.html#random-term

simple proof checker
