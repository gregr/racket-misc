===============================================================================
= current
===============================================================================
cursors:
  additional operator for multiple transformations in sequence
    more concise and more efficient
  default void constructor for :=% and friends
    won't be able to support varargs versions, but this is fine
  support non-list pairs

consolidate ui.rkt
  a lot of this is unnecessary

markout:
  design is sucking due to too many special cases; can it be fixed?
  seem to need height management, not just width
    draw tables twice, measuring the first time to provide measurement the second time?
      simplest quick fix; not a long term solution

kanren:
  remove deps upon use
    possibly gather relevant func-deps during muk-sub-add? can then also scrap muk-sub-prefix
  alternative constraint system approach based on interpretation of function terms
    type-of, all-diff, etc.
    muk-term = muk-var name | muk-function name [muk-term] | constants/aggregates
    interpretation result type: no-result-yet | actual-result result | simplification new-term
    implementation:
      unnesting of function terms; introduce new variables
      build unnested term substitutions
      dependency graph linking terms to their muk-var arguments
        learning something new about such an argument triggers re-application of the function
      application of functions:
        actual result? unify with expected result from substitution and erase term entry
        simplifies to a new term? replace the existing term entry in the substitution
        no result yet? be patient, return the same substitution
  support alternative search strategies
  constraints
    optional occurs-check?
    https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/impl/occur.html
      interesting sub-thread between torkel and pereira
  fix hash unification
  extended aggregate unification?
    sets and hashes with variable keys may have multiple component orderings
      unification could produce multiple possible subs

===============================================================================
= future
===============================================================================
logic/relational programming
  oleg's lambda term generation: http://okmij.org/ftp/Haskell/AlgorithmsH1.html#random-term

simple proof checker
