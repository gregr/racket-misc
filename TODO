===============================================================================
= current
===============================================================================
cursors:
  additional operator for multiple transformations in sequence
    more concise and more efficient
  default void constructor for :=% and friends
    won't be able to support varargs versions, but this is fine
  support non-list pairs

consolidate ui.rkt
  a lot of this is unnecessary

markout:
  design is sucking due to too many special cases; can it be fixed?
  seem to need height management, not just width
    draw tables twice, measuring the first time to provide measurement the second time?
      simplest quick fix; not a long term solution
  http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf

sugar:
  support 'values' patterns in more positions for efficiency
    letn

kanren:
  run-with-config
    eval-loop
      shape of the state
        substitution, constraint store, etc.
      unify
        control over which structures are internally unified
      constraints (optional)
        including occurs-check
      depth (if sensible WRT eval-loop)
    reify
      also shape of the state
  reification that does not depend on variables having names
  test efficiency of nameless variables
  constraints
    CHR
      https://en.wikipedia.org/wiki/Constraint_Handling_Rules
      http://www.informatik.uni-ulm.de/pm/fileadmin/pm/home/fruehwirth/constraint-handling-rules-book.html
      http://chr.informatik.uni-ulm.de/~webchr/
      http://www.csse.monash.edu.au/~mbanda/papers/refined.pdf
      http://www.sciencedirect.com/science/article/pii/S0743106698100055
    optional occurs-check?
      https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/impl/occur.html
        interesting sub-thread between torkel and pereira
    finite domains
      enumerations
      intervals
  minicurry
    match scheme syntax more closely to simplify porting
      some form of macros
      let[*]: wrap args, allow body to be conjunction, optional let-naming for looping
      letr: wrap args, allow body to be conjunction
        *maybe* generalize to take arbitrary arg values, not just lambdas
    metacircular interpreter
      may need to wait for additional constraints
      experiment with separating syntactic analysis from evaluation
      experiment with small-step operational semantics
      quines?
    benchmarks?
      particularly related to substitution size once this is measurable
    maybe try extending microkanren with by-need suspended computations, triggered by pause
      appropriate suspension to be unfrozen is identified by a key provided by pause
    mode inference and optimization
      can functional-only evaluation be detected and improved?
      make use of cost annotations
        complexity indicators to guide evaluation/search; dynamic? static only?
        static/dynamic termination checking?
  encodings (such as full-repr) instead of additional constraint system layers
    example: unification of type-encoded values eliminates the need for type constraints
      (symbolo x) ===> (exist (val) (== x (('symbol ()) val)))
      or
      (naturalo x) ===> (exist (val) (== x (('(number real exact integer natural) ()) val)))
      where x is a val that has been lifted by full-repr
    not even 1st class =/= is necessary with the right encoding
      but =/= being 1st class may be much more efficient for many structures
    alternative to functions: implicit encodings that take effect on all unified values
      reification can then perform decoding
  implicit views
    view, unview
    tagging
    =/=
    constraint-like reification
  improve performance
    measure substitution size growth
    compare efficiency of idempotent substitutions
    remove function terms and complex normalization during unification
    experiment with typed racket
    explicit cost annotation for unknown goals (or to override known computational cost)
      goals may override search strategy for their local computation tree
        for instance, running themselves to completion if they know they terminate
    support search priorities higher than unification?
      probably better to just override cost of expensive unifications
  specialized hash unification: keys always treated as fully ground

===============================================================================
= future
===============================================================================
logic/relational programming
  oleg's lambda term generation: http://okmij.org/ftp/Haskell/AlgorithmsH1.html#random-term

simple proof checker
